<!DOCTYPE html>
<html>
  <head>
    <title>Angular (Media Engineering Mobile Development)</title>
    <meta charset='utf-8'>
    <meta name='config' content='{&quot;basePath&quot;:&quot;../..&quot;,&quot;remark&quot;:{&quot;highlightLines&quot;:true,&quot;highlightSpans&quot;:true,&quot;countIncrementalSlides&quot;:false,&quot;navigation&quot;:{&quot;click&quot;:false,&quot;scroll&quot;:false,&quot;touch&quot;:true}},&quot;subjectUrl&quot;:&quot;https://github.com/MediaComem/comem-devmobil/tree/b9e10ba57ef3e19618e80a2b671226729f6d5142/subjects/angular/README.md&quot;}'>
  </head>
  <body>
    <textarea id='source'>
# Angular

Get started with and understand the basics of [Angular][angular], the JavaScript front-end web application framework.

This tutorial is a condensed version of Angular's [Tour of Heroes][angular-tour-of-heroes] tutorial and some of its [Developer Guide][angular-guide],
which you should both read to gain a deeper understanding of Angular.

This material is part of the [mobile development course](https://github.com/MediaComem/comem-devmobil) for [Media Engineering](https://heig-vd.ch/formations/bachelor/filieres/ingenierie-des-medias).

**You will need**

* [Google Chrome][chrome] (recommended, any browser with developer tools will do)

**Recommended reading**

* [JavaScript][js]
* [JavaScript classes][js-classes]
* [JavaScript modules][js-modules]
* [TypeScript][ts-subject]





---
class: center, middle, image-header
## What is Angular?

.breadcrumbs[<a href="#1">Angular</a>]



<p class='center'><img src='images/angular.png' width='20%' /></p>

> "Angular is a complete **JavaScript front-end web application framework** created by Google to address many of the challenges of developing **rich single-page applications**."



---
### Traditional Model-View-Controller (MVC) architecture

.breadcrumbs[<a href="#1">Angular</a> > <a href="#2">What is Angular?</a>]

In traditional MVC frameworks,
the application's **Controllers** receive the user's requests when navigating from page to page in the browser,
and respond by generating HTML **Views** from the **Model**.

<img src='images/mvc.png' width='100%' />



---
### DOM manipulation and AJAX requests

.breadcrumbs[<a href="#1">Angular</a> > <a href="#2">What is Angular?</a>]

.grid-60[

Serving dynamic HTML from the server works, but each user action requires that a **complete page be loaded** from the server.

To improve user experience:

* [AJAX][ajax] was developed in 1999 to retrieve data from the server asynchronously in the background
* [jQuery][jquery] was released in 2006 to simplify DOM manipulation and AJAX requests


]
.grid-40[

<img src='images/jquery-ajax.gif' class='w100' />


]
.container[

This allows you to load data from the server in the background and **dynamically update the page** without reloading.

Initially, these technologies were used to **enrich** existing HTML pages that were still built and served by a traditional MVC framework.




]
---
### Single-page applications

.breadcrumbs[<a href="#1">Angular</a> > <a href="#2">What is Angular?</a>]

.grid-50[

A single-page application (SPA) is a web application that **fits on a single web page** but provides a user experience similar to that of a **desktop application**:

* All content is retrieved with a **single page load or loaded dynamically**
* The page **does not reload** (location hash or [HTML 5 History API][html-history-api] to navigate between logical pages)
* Dynamic **communication with the web server** behind the scenes


]
.grid-50[

<img src='images/spa.png' width='100%' />




]
---
### Dynamic HTML with Angular

.breadcrumbs[<a href="#1">Angular</a> > <a href="#2">What is Angular?</a>]

> "AngularJS is what HTML would have been, had it been designed for building web-apps."

HTML is great for displaying static documents, but is not so good at describing the **dynamic views** needed for **rich, interactive applications**.

With Angular, you can:
  * **Automatically bind data** to HTML elements
  * **Extend the HTML vocabulary** with new elements and attributes
  * **Isolate** your application logic from how the data is displayed



---
### Evolution of Angular

.breadcrumbs[<a href="#1">Angular</a> > <a href="#2">What is Angular?</a>]

Angular is one of the most popular client-side frameworks, and it is still evolving.
Starting with version 2 of the framework (released in June 2016) you can take advantage of:

* [TypeScript][ts]: a superset of JavaScript with optional typing and the latest ECMAScript features
* [Web components][web-components]: a way to create reusable user interface widgets
* And more...



---
class: center, middle
## Getting started

.breadcrumbs[<a href="#1">Angular</a>]





---
### Starter template

.breadcrumbs[<a href="#1">Angular</a> > <a href="#8">Getting started</a>]

If you want to follow along this tutorial, you can generate a new barebone angular application.

To do so, in the directory where you want to generate the application folder, execute the following script:

```bash
$> npx @angular/cli new comem-angular-starter
```

When asked, respond with the following answers:
```bash
? Would you like to add Angular routing? `No`
? Which stylesheet format would you like to use? `SCSS`
```

Wait for the generator to end (this may take several minutes), then go to the newly created folder and start the development server:

```bash
$> cd comem-angular-starter
$> npm start
```
When the CLI tells you so, go to [`http://localhost:4200`](http://localhost:4200). Don't forget to keep your [developer console][chrome-dev] open throughout this tutorial to detect errors in your code.

---
### Overview

.breadcrumbs[<a href="#1">Angular</a> > <a href="#8">Getting started</a>]

.grid-50[

**Angular elements**

* Modules
* Components
* Directives
* Services
* HTTP
* Pipes


]
.grid-50[

**Angular concepts**

* Interpolation
* Data binding
* Dependency injection
* Observables & reactive programming
* Form validation




]
---
### Modules

.breadcrumbs[<a href="#1">Angular</a> > <a href="#8">Getting started</a>]

An Angular application is a **module**.
You can find one in `src/app/app.module.ts` in the starter project:

```ts
import { BrowserModule } from '@angular/platform-browser';
import { NgModule } from '@angular/core';

import { AppComponent } from './app.component';

`@NgModule`({
  declarations: [
    AppComponent
  ],
  imports: [
    BrowserModule
  ],
  providers: [],
  bootstrap: [AppComponent]
})
export `class AppModule` { }
```

A module is a way to help organize related things (components, services, etc) together.

---
#### Basic module definition

.breadcrumbs[<a href="#1">Angular</a> > <a href="#8">Getting started</a> > <a href="#11">Modules</a>]

Take a look at the [`@NgModule`][angular-docs-ng-module] annotation:

```ts
@NgModule({
  `declarations`: [
    AppComponent
  ],
  `imports`: [
    BrowserModule
  ],
  `providers`: [],
  `bootstrap`: [AppComponent]
})
```

* The **declarations** array is a list of components (also directives and pipes) which belong to this module.
* The **imports** array is a list of other modules whose exported components should be available in this module.
  It allows you to express a dependency on another module.
* The **providers** array is a list of service providers (more about that later).
* **bootstrap** is the root component that Angular creates and inserts into `index.html`



---
### Components

.breadcrumbs[<a href="#1">Angular</a> > <a href="#8">Getting started</a>]

Components are the most basic **building block** of an UI in an Angular application.
An Angular application is a tree of Angular components.

You will find a component in `src/app/app.component.ts` in the starter project:

```ts
import { Component } from '@angular/core';

`@Component`({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export `class AppComponent` {
  title = 'comem-angular-starter';
}
```

A component is any [JavaScript class][js-classes] annotated with the [`@Component`][angular-docs-component] decorator.

Let's dig into that line by line.

---
#### Component selector

.breadcrumbs[<a href="#1">Angular</a> > <a href="#8">Getting started</a> > <a href="#13">Components</a>]

The `selector` property of the `@Component` decorator indicates what tag you should put in your HTML to instantiate the component:

```ts
@Component({
  `selector: 'app-root'`,
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
```

Open `src/index.html` in the starter project.
You will find the `<app-root>` tag:

```html
<body>
  `<app-root></app-root>`
&lt;/body&gt;
```

---
#### Component template

.breadcrumbs[<a href="#1">Angular</a> > <a href="#8">Getting started</a> > <a href="#13">Components</a>]

The `templateUrl` property of the `@Component` decorator tells Angular which HTML file to use to display the component:

```ts
@Component({
  selector: 'app-root',
  `templateUrl: './app.component.html'`,
  styleUrls: ['./app.component.css']
})
```

For very simple components, you can also use `template` instead of `templateUrl` to use an **inline template**:

```ts
@Component({
  selector: 'app-root',
  `template: '<h1>Welcome to {{ title }}!</h1>'`,
  styleUrls: ['./app.component.css']
})
```

---
#### Component styles

.breadcrumbs[<a href="#1">Angular</a> > <a href="#8">Getting started</a> > <a href="#13">Components</a>]

Similarly, the `styleUrls` property is a list of CSS files to apply to the component:

```ts
@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  `styleUrls: ['./app.component.css']`
})
```

It's also possible to use **inline styles** for very simple components:

```ts
@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  `styles: [ 'h1 { font-weight: normal;  }' ]`
})
```

Styles in Angular are **modular**.
They apply only *within the template of that component*.

Read the [Component Styles][angular-component-styles] documentation to learn more.



---
### Data binding

.breadcrumbs[<a href="#1">Angular</a> > <a href="#8">Getting started</a>]

You can display data by **binding** parts of an HTML template to properties of a component.

There is already a `title` property in `AppComponent` in `src/app/app.component.ts`:

```ts
export class AppComponent {
  title = 'comem-angular-starter';
}
```

Enclosing a component's property name in double curly braces in the template is called **interpolation**.

You can do so in the `AppComponent`'s template in `src/app/app.component.html` by removing **all** the biolerplate content and pasting the following code:

```html
<h1>
  Welcome to `{{ title }}`!
</h1>
```

---
#### Attribute binding

.breadcrumbs[<a href="#1">Angular</a> > <a href="#8">Getting started</a> > <a href="#17">Data binding</a>]

Let's see what else we can interpolate.

Let's rewrite the `AppComponent`'s class definition and add a new `titleComment` property to the component in `src/app/app.component.ts`:

```ts
export class AppComponent {
  title: string;
  `titleComment: string;`

  constructor() {
    this.title = 'comem-angular-starter';
    `this.titleComment = 'This is awesome!';`
  }
}
```

Angular's `[]` syntax allows you to bind the value of a DOM element's **attribute** to one of the component's variables.
You can do this in `src/app/app.component.html`:

```html
<h1 `[title]='titleComment'`>
  Welcome to {{ title }}!
</h1>
```

---
##### To bind, or not to bind

.breadcrumbs[<a href="#1">Angular</a> > <a href="#8">Getting started</a> > <a href="#17">Data binding</a> > <a href="#18">Attribute binding</a>]

Note the two ways to interpolate attributes.
Here, as in the previous example, the `[]` syntax **binds the the `title` attribute** to the `titleComment` variable:

```html
<h1 `[title]='titleComment'`>
  Welcome to {{ title }}!
</h1>
```

Here, the `title` attribute itself is not bound, but its **value is interpolated** with the `{{  }}` syntax.
The behavior will be the same as the previous example:

```html
<h1 title='`{{ titleComment }}`'>
  Welcome to {{ title }}!
</h1>
```

Here, we made a **mistake**.
We neither bound the attribute, nor used interpolation in its value,
so the value of the attribute will be the string `"titleComment"`,
not the value of the corresponding variable:

```html
<h1 title='titleComment'>
  Welcome to {{ title }}!
</h1>
```

---
#### Binding to events

.breadcrumbs[<a href="#1">Angular</a> > <a href="#8">Getting started</a> > <a href="#17">Data binding</a>]

Let's imagine that we want to log something when the user clicks on the title.
Add an `onTitleClicked()` method to the component's class in `src/app/app.component.ts`:

```ts
export class AppComponent {
  // ...

* onTitleClicked() {
*   console.log('The title was clicked');
* }
}
```

Angular's `()` syntax allows you to **bind functions to events** from a DOM element.
Let's bind the function we just added to click events on the `<h1>` tag in `src/app/app.component.html`:

```html
<h1 [title]='titleComment' `(click)='onTitleClicked()'`>
  Welcome to {{ title }}!
</h1>
```

You should now see the message being logged in the console when clicking on the title.

---
##### Getting at the event

.breadcrumbs[<a href="#1">Angular</a> > <a href="#8">Getting started</a> > <a href="#17">Data binding</a> > <a href="#20">Binding to events</a>]

You might need the actual [event object][dom-event] to get some data out of it (e.g. the click coordinates).
Let's update `onTitleClicked()` in `src/app/app.component.ts` to also log the event object:

```ts
export class AppComponent {
  // ...

  onTitleClicked(`event: MouseEvent`) {
    console.log('The title was clicked'`, event`);
  }
}
```

To make it work, simply pass the special `$event` variable as an argument to your function call in `src/app/app.component.html`, and Angular will pass the event object to your function:

> Note that you **must** use exactly the name `$event` as the argument's name

```html
<h1 [title]='titleComment' (click)='onTitleClicked(`$event`)'>
  Welcome to {{ title }}!
</h1>
```

---
#### Interpolation with functions

.breadcrumbs[<a href="#1">Angular</a> > <a href="#8">Getting started</a> > <a href="#17">Data binding</a>]

Interpolation is not limited to simple properties.
You can also use a component's **method** in the template.

Add the following method to the component in `src/app/app.component.ts`:

```ts
export class AppComponent {
  // ...

* hello(name: string): string {
*   return \`Hello ${name}`;
* }
}
```

Now use that function in the template in `src/app/app.component.html`:

```html
<!-- Add this to the end of the file -->
<p>
  `{{ hello("World") }}`
</p>
```
> Change the value passsed to the `hello()` function to see it change.

---
## User input

.breadcrumbs[<a href="#1">Angular</a>]

One of the things you will need to do is **react to user input** (e.g. through forms).
Let's make our greeting **dynamic** by adding an input field to customize the name.
Make the following changes to the component in `src/app/app.component.ts`:

```ts
export class AppComponent {
  // ...
  `greeting: string;`

  constructor() {
    this.title = 'app';
    `this.greeting = '';`
  }
  // ...
}
```

Now interpolate that new property into the `hello` function in the template in `src/app/app.component.html`:

```html
<p>
  {{ hello(`greeting`) }}
</p>
```

---
### `ngModel`

.breadcrumbs[<a href="#1">Angular</a> > <a href="#23">User input</a>]

Add an input field to the template above the greeting in `src/app/app.component.html`:

```html
*<p>
* <input type='text' placeholder='Who are you?' [(ngModel)]='greeting' />
*</p>
<p>
  {{ hello(greeting) }}
</p>
```

`[(ngModel)]` is Angular's **two-way data binding** syntax.
It binds the `greeting` property to the HTML input field.

You will most likely get this error:

```
Uncaught Error: Template parse errors:
Can't bind to 'ngModel' since it isn't a known property of 'input'.
```

This is because `[(ngModel)]` belongs to the optional `FormsModule`, which you have to *opt in* to using.

---
#### `FormsModule`

.breadcrumbs[<a href="#1">Angular</a> > <a href="#23">User input</a> > <a href="#24">`ngModel`</a>]

To **import** the module into your application, you must add it to the `imports` array of your own module in `src/app/app.module.ts`:

```ts
// Other imports...
*import { FormsModule } from '@angular/forms';

@NgModule({
  declarations: [
    AppComponent
  ],
  imports: [
    BrowserModule,
    `FormsModule`
  ],
  providers: [],
  bootstrap: [AppComponent]
})
export class AppModule { }
```

Once you've done that, the field should display correctly.

Note that as you type in the input field, the `greeting` variable is **automatically kept up-to-date**,
and Angular **updates the template** to reflect its new value.

---
### Two-way data binding

.breadcrumbs[<a href="#1">Angular</a> > <a href="#23">User input</a>]

.grid-50[

Traditional templating systems bind data **in only one direction**.

The developer has to write code that constantly syncs the view with the model and vice versa.

<img src='images/one-way-data-binding.png' width='100%' />


]
.grid-50[

With Angular changes are **immediately reflected** in both view and model.

Also note that our **component** is **isolated from and unaware of the view**:
it does not care about DOM manipulation or rendering concerns.

<img src='images/two-way-data-binding.png' width='100%' />




]
---
## Directives

.breadcrumbs[<a href="#1">Angular</a>]

A **directive** is a class with a `@Directive` decorator.

The **component** that we've seen before is a *directive-with-a-template*.
A `@Component` decorator is actually a `@Directive` decorator extended with template-oriented features.

Two other kinds of directives exist: **structural** and **attribute** directives.

---
### Structural directives

.breadcrumbs[<a href="#1">Angular</a> > <a href="#27">Directives</a>]

Structural directives are responsible for HTML layout.
They shape or reshape the **DOM's structure**, typically by **adding, removing, or manipulating elements**.

Let's add the [`ngIf`][angular-docs-ng-if] directive to our template in `src/app/app.component.html` as an example:

```html
<p `*ngIf='greeting'`>
  {{ hello(greeting) }}
</p>
```

> The `*` before `ngIf` in the template is not a typo ; structural directives must **always** be preceeded by a `*`.

As you can see, the entire paragraph is now removed from the DOM as long as the `greeting` property is blank (e.g. `undefined` or an empty string).
It is added back as soon as `greeting` has a value.

Read the [documentation][angular-structural-directives] to learn more about structural directives.
Many more such directives are provided by Angular out of the box, like [`ngFor`][angular-docs-ng-for] (which we'll use later) and [`ngSwitch`][angular-docs-ng-switch].

---
### Attribute directives

.breadcrumbs[<a href="#1">Angular</a> > <a href="#27">Directives</a>]

> Want to create your own attributes directives ? See [advanced-angular][advanced-angular-subject]

An **attribute** directive changes the **appearance or behavior of a DOM element**.

Let's say we want to programmatically add or remove classes to our `<h1>` tag in our template.

First, open the `src/app/app.component.ts` to add a new property to the component's class called, for example, `titleClasses`:

```ts
export class AppComponent {
  // Previous properties
* titleClasses: { [ name: string ]: boolean };

  constructor() {
    // ...
*   this.titleClasses = {
*     italic: true,
*     hoverable: true
*   };
  }
  // ...
}
```

---
#### Define and bind the classes

.breadcrumbs[<a href="#1">Angular</a> > <a href="#27">Directives</a> > <a href="#29">Attribute directives</a>]

We need to declare those two classes in our component's style. Open the `app.component.scss` file and add them there:

```scss
.italic { font-style: italic; }

.hoverable { cursor: pointer; }
```

Now, we can use Angular's `ngClass` attribute selective to bind the `titleClasses` oject to our `<h1>` title:

```html
<h1 `[ngClass]="titleClasses"` [title]='titleComment' (click)="onTitleClicked($event)">
  Welcome to {{ title }}!
</h1>
```
> For each `titleClasses`'s property whose value is `true`, `ngClass` will add to the element a CSS class of the same name.

> You can try changing the `titleClasses` properties value or add your own to see how that reflects to the element's classes.

---
### Common directives

.breadcrumbs[<a href="#1">Angular</a> > <a href="#27">Directives</a>]

These common directives are provided by Angular out of the box:

**Structural directives**

* [`ngFor`][angular-docs-ng-for] - Instantiates a template **once per item** from an iterable.
* [`ngIf`][angular-docs-ng-if] - **Conditionally includes** a template based on the value of an expression.
* [`ngSwitch`][angular-docs-ng-switch] - Adds/removes DOM sub-trees when the nest match expressions matches the **switch** expression.

**Attribute directives**

* [`ngClass`][angular-docs-ng-class] - Adds and removes **CSS classes** on an HTML element.
* [`ngModel`][angular-docs-ng-model] - **Two-way binding** between a form's input field and a component's variable.
* [`ngPlural`][angular-docs-ng-plural] - Adds/removes DOM sub-trees based on a numeric value. (Tailored for **pluralization**.)
* [`ngStyle`][angular-docs-ng-style] - Update an HTML element's **styles**.


---
## Pipes

.breadcrumbs[<a href="#1">Angular</a>]

When primitive values or objects are interpolated into a template, they are serialized by Angular using their `toString()` method.

That's fine for strings, but not for everything:

* What about **numbers**? You might not want to display all their decimals.
* What about **currencies**? They are usually displayed in a specific format.
* What about **dates**? You might want to use a simple format like `April 15, 1988` rather than the default `Fri Apr 15 1988 00:00:00 GMT-0700 (Pacific Daylight Time)`.

Clearly, some values benefit from a bit of editing and that's what Pipes are all about.

They're special functions that your value will pass through before being rendered in the template.

> Want to implement your own pipes? See [advances-angular][advanced-angular-subject]

---
### Use case

.breadcrumbs[<a href="#1">Angular</a> > <a href="#32">Pipes</a>]

Open the `src/app/app.component.ts` file and add a new `progress` property:

```ts
export class AppComponent {
  // Previous properties
* progress: number;

  constructor() {
    // ...
*   this.progress = 0.33;
  }
  // ...
}
```

We want to display this value as a percentage in our template. We _could_ do it like so:

```html
<p>{{ progress * 100 }}%</p>
```
Doing so implies that we repeat this same snippet each time we want to display a percentage in our app. This is error prone as we might forget the `%`, or add an exceeding `0` when multiplying our value, etc.

We'd be better off having this formula in a `Pipe` so we could use it any time we want.

---
### Using a pipe

.breadcrumbs[<a href="#1">Angular</a> > <a href="#32">Pipes</a>]

In this case, Angular provides us with a `Pipe` named `percent` that does display values as percentages and thus, can help us rendering our progress percentage in our template.

Actually using the pipe is as simple as "piping" an interpolated value into it with the pipe (`|`) character in a template:

```html
<p>We've only done {{ progress` | percent` }} of those damned slides</p>
```

> You can see that this built-in pipe multiply the given value and add the `%` character at the end.

---
### Angular built-in pipes

.breadcrumbs[<a href="#1">Angular</a> > <a href="#32">Pipes</a>]

Angular provides [a few pipes][angular-docs-pipes] out of the box.
Here's some of them:

* [`CurrencyPipe`][angular-docs-currency-pipe]
* [`DatePipe`][angular-docs-date-pipe]
* [`DecimalPipe`][angular-docs-decimal-pipe]
* [`LowerCasePipe`][angular-docs-lowercase-pipe], [`UpperCasePipe`][angular-docs-uppercase-pipe] & [`TitleCasePipe`][angular-docs-titlecase-pipe]
* [`PercentPipe`][angular-docs-percent-pipe]

Here's few usage examples for [`DatePipe`][angular-docs-date-pipe]:

```html
<!-- Output: Jun 15, 2015 -->
<p>Today is {{ dateValue | date }}</p>

<!-- Output: Monday, June 15, 2015 -->
<p>Or if you prefer, {{ dateValue | date:'fullDate' }}</p>

<!-- Output: 9:43 AM -->
<p>The time is {{ dateValue | date:'shortTime' }}</p>
```

Read [more about pipes][angular-pipes] in the developer guide.

---
## Models

.breadcrumbs[<a href="#1">Angular</a>]

Now, let's make our application funny by adding some jokes.

It's good practice to create **classes** for your **business models**.
A TypeScript class with clearly defined fields and types will help us avoid mistakes in our code.
Let's start with a very simple one.

Angular CLI comes with scaffolding tools to help you create files. You can access the Angular CLI using the `npm run ng` script.
Let's use this to generate a new blank class:

```bash
$> npm run ng generate class models/joke
```

This will create a `src/app/models/joke.ts` file (and it's corresponding `joke.spec.ts` file that you can ignore).
Open it and add a `text` attribute to our new `Joke` class:

```ts
export class Joke {
  `text: string;`
}
```

---
### Using models

.breadcrumbs[<a href="#1">Angular</a> > <a href="#36">Models</a>]

Let's add some jokes to our component in `src/app/app.component.ts`:

```ts
// Other imports...
`import { Joke } from './models/joke';`

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent {
  // ...previous properties
  `jokes: Joke[];`

  constructor() {
    // ...
*   this.jokes = [
*     { text: 'Knock knock' },
*     { text: 'The cake is a lie' }
*   ];
  }
  // ...
}
```

---
### Using `ngFor`

.breadcrumbs[<a href="#1">Angular</a> > <a href="#36">Models</a>]

Now that we have some jokes, let's display them.
We want a `<ul>` list, with a `<li>` item for each joke.
That's a job for the [`ngFor`][angular-docs-ng-for] directive.

Add this at the bottom of the component's template in `src/app/app.component.html`:

```html
<ul>
  <li *ngFor='let joke of jokes'>{{ joke.text }}</li>
</ul>
```

The directive handles repeating the `<li>` element for us.
No need to write it multiple times, or to manually build and concatenate DOM elements in the component's TypeScript code.

---
### Using `ngPlural`

.breadcrumbs[<a href="#1">Angular</a> > <a href="#36">Models</a>]

While we're at it, let's also add a header above the list:

```html
<h2>
  {{ jokes.length }} jokes
</h2>
```

You might notice that we'll have a minor problem when there is only one joke.
It will say "1 jokes" instead of "1 joke".

The [`ngPlural`][angular-docs-ng-plural] directive comes to the rescue:

```html
<h2 `[ngPlural]='jokes.length'`>
  {{ jokes.length }}
* <ng-template ngPluralCase='=1'>joke</ng-template>
* <ng-template ngPluralCase='other'>jokes</ng-template>
</h2>
```

---
## Services

.breadcrumbs[<a href="#1">Angular</a>]

Let's do something more interesting: fetch some jokes from the internet.

To do it "The Angular Way", we'll encapsulate that functionality into a **service**.

Why?
**Components** should not try to do too much;
they should focus on **presenting data** and **delegate data access** to specialized classes.
**Services** are here to fill that role.

This helps your components remain as simple as possible while services handle your business logic.

Let's use Angular CLI to generate a joke service:

```bash
$> npm run ng generate service services/joke
```
Again, you can ignore the generated `joke.spec.ts` file.

---
### The joke service

.breadcrumbs[<a href="#1">Angular</a> > <a href="#40">Services</a>]

The `src/app/services/joke.service.ts` file has been generated:

```ts
import { Injectable } from '@angular/core';

@Injectable({ providedIn: 'root' })
export class JokeService {
  constructor() { }
}
```

Once again, a service is simply a JavaScript class, annotated with the [`@Injectable`][angular-docs-injectable] decorator.
More about that later.

For now, simply add a method which returns a joke:

```ts
import { Injectable } from '@angular/core';
`import { Joke } from '../models/joke';`

@Injectable({ providedIn: 'root' })
export class JokeService {
  constructor() { }

* getJoke(): Joke {
*   return { text: 'Knock knock' };
* }
}
```

---
### Providing the joke service

.breadcrumbs[<a href="#1">Angular</a> > <a href="#40">Services</a>]

You may have notice the `providedIn: 'root'` property in the `@Injectable` param object of the generated service.

This particular settings indicates that **the service is provided (meaning: made available) at the root of your application**.

This way, you can **inject it in any of your component** out-of-the-box.

You might encouter `Services` that do not have this setting in their `@Injectable` decorator (i.e. when using external libraries). If this is the case, you must **provide** them in a module's `providers` array:

```ts
// Other imports...
import { SomeService } from './some/directory';

@NgModule({
  // ...
  providers: [
    `SomeService`
  ],
  // ...
})
export class SomeModule { }
```

---
### Injecting the joke service

.breadcrumbs[<a href="#1">Angular</a> > <a href="#40">Services</a>]

Now, you can **inject** the service into your component in `src/app/app.component.ts`.

You just have to add a **constructor parameter property**.
While you're at it, also add a **method to add a joke**:

```ts
// Other imports...
*import { JokeService } from './services/joke.service';

export class AppComponent {
  // ...
  constructor(`private jokeService: JokeService`) {
    // ...
  }

* addJoke() {
*   this.jokes.push(this.jokeService.getJoke());
* }
  // ...
}
```

---
#### Calling a method from a button

.breadcrumbs[<a href="#1">Angular</a> > <a href="#40">Services</a> > <a href="#43">Injecting the joke service</a>]

To use our new method, you can add a button in the template in `src/app/app.component.html`:

```html
<p>
  <button type='button' (click)='addJoke()'>Add joke</button>
</p>
```

The `(click)` attribute is Angular's syntax to listen to the `click` event on a DOM element and trigger something when it occurs.

---
### Why does it work?

.breadcrumbs[<a href="#1">Angular</a> > <a href="#40">Services</a>]

Our component now uses the service.
But why does it work?
All you did was add a parameter property to the constructor:

```ts
constructor(`private jokeService: JokeService`) {
  // ...
}
```

As a reminder, in TypeScript this is equivalent to:

```ts
export class AppComponent {
  `jokeService: JokeService;`

  constructor(`jokeService: JokeService`) {
    `this.jokeService = jokeService;`
  }
}
```

You **never instantiated the service with `new`**, so where is the instance coming from?

---
### Dependency injection

.breadcrumbs[<a href="#1">Angular</a> > <a href="#40">Services</a>]

Angular relies on [dependency injection][di] to plug components, services and other elements together.

* As previously said, your service is **provided** in the **root** of your application.
* This makes it possible for Angular's **injector** to know that your service exists and to create instances of it.
* By adding the parameter to the component's constructor, you **asked Angular to inject** an instance of the service at runtime.

Dependency injection is a form of [inversion of control][ioc],
meaning that parts of your code **receive** the flow of control instead of driving it like in classic procedural programming.
The general goal is to:

* **Decouple** the execution of a task from implementation.
* **Focus** a component on the task it is designed for.
* **Free components from assumptions** about how other systems do what they do and instead rely on **contracts**.
* **Prevent side effects** when **replacing** a component.

---
#### Why dependency injection?

.breadcrumbs[<a href="#1">Angular</a> > <a href="#40">Services</a> > <a href="#46">Dependency injection</a>]

.grid-50[

**Strong coupling**

```js
function Car() {
  this.engine = new Engine(24);
}
function Engine(gasLead) {
  this.gas = new Gas(gasLead);
}
function Gas(lead) {
  this.lead = lead;
}
```

<img src='images/di-new.png' width='100%' />


]
.grid-50[

**Loose coupling** (with an *injector*)

```js
function Car(engine) {
  this.engine = engine;
}
function Engine(gas) {
  this.gas = gas;
}
function Gas(lead) {
  this.lead = lead;
}
```

<img src='images/di-injection.png' width='100%' />




]
---
## Observable data

.breadcrumbs[<a href="#1">Angular</a>]

Our current `getJoke()` method has a **synchronous** signature; implying that data is returned right away:

```ts
const joke = jokeService.getJoke();
```

This will **not** work when fetching jokes from a **remote server**, which is inherently an **asynchronous** operation.

The `getJoke()` method must be modified to not immediately return a joke, but to have an asynchronous signature instead.
It could take a **callback** or return a [**Promise**][js-promise].

Another solution is to return an **Observable**.
Angular includes the [RxJS][rxjs] library for reactive programming using Observables,
to make it easier to compose asynchronous or callback-based code.

> To learn more about `Observables` and the `RxJS` library, see [the corresponding subject][rxjs-subject].

---
### What (the hell) is an observable?

.breadcrumbs[<a href="#1">Angular</a> > <a href="#48">Observable data</a>]

An observable is an **asynchronous data stream**, meaning that it allows you to observe **multiple events over time**.

<p class='center'><img src='images/promises-observables.png' class='w80' /></p>

For example, a user's **mouse clicks** on a website could be easily be modeled as an observable:
there will be several of them and they will happen at different times in the future.

---
### What (the hell) is reactive programming?

.breadcrumbs[<a href="#1">Angular</a> > <a href="#48">Observable data</a>]

Basically, **reactive programming** is programming with **asynchronous** data **streams**.

<p class='center'><img src='images/reactive-programming.png' class='w50' /></p>

RxJS is a library which provides an amazing toolbox of functions to **combine, create and filter** any of those streams.

In Angular 2+, many asynchronous operations are represented as Observable streams.
For example, making an **HTTP call** will return an **Observable** which emits either a **response** or an **error**.
You may **subscribe** to that observable to be notified of the result of the asynchronous call.

To learn more about reactive programming,
you may want to read ["The introduction to Reactive Programming you've been missing"][intro-to-reactive-programming].

---
### Making `getJoke()` observable

.breadcrumbs[<a href="#1">Angular</a> > <a href="#48">Observable data</a>]

Since Angular's `HttpClient` returns **Observables**, that's what we'll use.

For now, let's modify the signature of our `getJoke()` method in `JokeService` in `src/app/services/joke.service.ts` to return an `Observable` of a `Joke`, without actually making an HTTP call yet:

```ts
// Other imports...
*import { Observable, of } from 'rxjs';

@Injectable()
export class JokeService {
  // ...
  getJoke(): `Observable<Joke>` {
    return `of({ text: 'Knock knock' })`;
  }
}
```

> Note the `<>` in `Observable<Joke>`. Thie a special TypeScript syntax used to clarifiy a type. Here, it says that not only the method returns an `Observable`, but its emitted values will be instances of `Joke`.

`of` allows us to create an observable stream which will simply emit the specified value, or values (here, the `Joke`) and complete.

---
### Subscribing to an Observable

.breadcrumbs[<a href="#1">Angular</a> > <a href="#48">Observable data</a>]

Of course, the code in our component no longer works now,
since it expects a `Joke` and gets an Observable of a `Joke` instead:

```
ERROR in src/app/app.component.ts(26,21): error TS2345:
  Argument of type 'Observable<Joke>' is not assignable to parameter of type 'Joke'.
  Property 'text' is missing in type 'Observable<Joke>'.
```

Use the `subscribe` method of the Observable to be notified when a Joke is emitted on the stream in `AppComponent` in `src/app/app.component.ts`:

```ts
addJoke() {
* this.jokeService.getJoke().subscribe(joke => {
*   this.jokes.push(joke);
* });
}
```

We now have our **asynchronous** implementation:

* We **subscribe** to the Observable when `addJoke` is called.
* But the **callback** adding the new joke into the array will be called **later**,
  after the data has been fetched from the remote server.



---
## Making HTTP calls

.breadcrumbs[<a href="#1">Angular</a>]

Time to actually fetch some jokes from the internet.
We'll need Angular's [`HttpClient`][angular-docs-http-client].
It is part of `HttpClientModule`, so we need to import that to our own application module, `AppModule`, in `src/app/app.module.ts`:

```ts
// Other imports...
*import { HttpClientModule } from '@angular/common/http';

@NgModule({
  // ...
  imports: [
    BrowserModule,
    FormsModule,
    `HttpClientModule`
  ],
  // ...
})
export class AppModule { }
```

---
### Injecting `HttpClient`

.breadcrumbs[<a href="#1">Angular</a> > <a href="#53">Making HTTP calls</a>]

Earlier we annotated `JokeService` with the [`@Injectable`][angular-docs-injectable] decorator.
This not only makes it available to the **injector** for creation,
but also allows it to **inject dependencies of its own**.

Now that `HttpClientModule` is available, you can inject `HttpClient` into `JokeService` in `src/app/services/joke.service.ts`:

```ts
// Other imports...
*import { HttpClient } from '@angular/common/http';

@Injectable()
export class JokeService {
  constructor(`private http: HttpClient`) { }
  // ...
}
```

---
### Joke API response

.breadcrumbs[<a href="#1">Angular</a> > <a href="#53">Making HTTP calls</a>]

The API we are going to call returns JSON data that looks like this:

```json
{
  "type": "success",
  "value": {
    "categories": [],
    "id": 1,
    "joke": "Knock knock"
  }
}
```

This does not fit our `Joke` model, which only has a `text` property.

---
#### Joke API response model

.breadcrumbs[<a href="#1">Angular</a> > <a href="#53">Making HTTP calls</a> > <a href="#55">Joke API response</a>]

Let's create a new `JokeResponse` model that we can use with this API:

```bash
$> npm run ng generate class models/joke-response
```

This generates a new model file in `src/app/models/joke-response.ts`.
Update it to reflect the **structure** of the API response.
Since it's a nested structure, we'll need **2 classes**:

```ts
export class JokeResponse {
  type: string;
  value: JokeResponseValue;
}

export class JokeResponseValue {
  categories: string[];
  id: number;
  joke: string;
}
```

---
### Making a GET call

.breadcrumbs[<a href="#1">Angular</a> > <a href="#53">Making HTTP calls</a>]

We can now update `getJoke()` in `src/app/services/joke.service.ts` to make an actual HTTP call:

```ts
// Other imports...
*import { JokeResponse } from '../models/joke-response';

@Injectable()
export class JokeService {
  // ...
  getJoke(): Observable<Joke> {
*   return this.httpClient
*     .get<JokeResponse>('https://api.icndb.com/jokes/random');
  }
}
```

As you can see by the use of the `<>`, we also specified that the [`HttpClient`][angular-docs-http-client]'s `get` method is supposed to receive data matching the `JokeResponse` model after the call completes. This helps TypeScript understand our code better.
But we're still left with one problem: we need an Observable of `Joke` objects, and have one of `JokeResponse` objects instead:

```
ERROR in src/app/services/joke.service.ts(15,5): error TS2322:
  Type 'Observable<JokeResponse>' is not assignable to type 'Observable<Joke>'.
  Type 'JokeResponse' is not assignable to type 'Joke'.
  Property 'text' is missing in type 'JokeResponse'.
```

---
### Transforming data

.breadcrumbs[<a href="#1">Angular</a> > <a href="#53">Making HTTP calls</a>]

We need to be able to transform a `JokeResponse` object into a `Joke`.
Let's add a utility function at the bottom of the file in `src/app/services/joke.service.ts`:

```ts
function convertJokeResponseToJoke(response: JokeResponse): Joke {
  return {
    text: response.value.joke
  };
}
```

---
### Transforming Observable streams

.breadcrumbs[<a href="#1">Angular</a> > <a href="#53">Making HTTP calls</a>]

Similarly to the [`map`][js-array-map] method of JavaScript arrays, Observables have a [`map`][observable-map] operator,
which allows you to transform each item emitted in the stream:

<p class='center'><img src='images/observable-map.png' class='w50' /></p>

To use it, you need to import it and use the Observable's `pipe` method in `JokeService` in `src/app/services/joke.service.ts`:

```ts
// Other imports...
*import { map } from 'rxjs/operators';

// ...
  getJoke(): Observable<Joke> {
    return this.httpClient
      .get<JokeResponse>('https://api.icndb.com/jokes/random')
*     .pipe(map(convertJokeResponseToJoke));
  }
```

---
### Reacting to errors in observable streams

.breadcrumbs[<a href="#1">Angular</a> > <a href="#53">Making HTTP calls</a>]

An observable stream may emit an **error**.
You can be notified of that error by passing a second callback function to `subscribe` in `AppComponent` in `src/app/app.component.ts`:

```ts
addJoke() {
  this.jokeService.getJoke().subscribe(joke => {
    this.jokes.push(joke);
  }`, err => {`
    `console.warn('Could not get new joke', err);`
  `}`);
}
```

For the purpose of testing this new behavior,
you can produce an error by changing the URL in `JokeService`in `src/app/services/joke.service.ts`,
so that the call fails.
You should then see an error in the console when adding a joke:

```ts
getJoke(): Observable<Joke> {
  return this.httpClient
    .get<JokeResponse>('https://`foo.example.com`/jokes/random')
    .pipe(map(convertJokeResponseToJoke));
}
```

You can then change it back to the correct URL.

---
### Getting the HTTP response

.breadcrumbs[<a href="#1">Angular</a> > <a href="#53">Making HTTP calls</a>]

We've seen that by default, Angular's `HttpClient` returns only the **body of the response**
(this is a *generic example*; do **not** make this change to the project):

```ts
function getJoke(): Observable<JokeResponse> {
  return this.httpClient
    .get<JokeResponse>('https://api.icndb.com/jokes/random');
}

getJoke().subscribe(jokeResponse => {
  // "jokeResponse" has type JokeResponse
  console.log(jokeResponse.value.joke);
  // "Chuck Norris can make a class that is both abstract and final."
});
```

That's nice, but in some cases we might need access to the **HTTP status** or **headers** sent by the server in the response.

---
#### Observing the response

.breadcrumbs[<a href="#1">Angular</a> > <a href="#53">Making HTTP calls</a> > <a href="#61">Getting the HTTP response</a>]

To get Angular's `HttpClient` to give you the full [`HttpResponse`][angular-docs-http-response] object,
you need to pass an additional options object to your HTTP call,
with the `observe` property set to `"response"` (this is also a *generic example*):

```ts
function getJoke(): Observable<`HttpResponse<JokeResponse>`> {
  `const options = { observe: 'response' };`
  return this.httpClient
    .get<JokeResponse>('https://api.icndb.com/jokes/random'`, options`);
}

getJoke().subscribe(httpResponse => {
  // "httpResponse" has type HttpResponse<JokeResponse>
  console.log(httpResponse.status); // 200
  // "httpResponse.body" has type JokeResponse
  console.log(httpResponse.body.value.joke);
  // "Chuck Norris can make a class that is both abstract and final."
});
```

Now, you no longer get an Observable of `JokeResponse` objects,
but instead get an Observable of `HttpResponse<JokeResponse>` objects.
That is, the full HTTP response, with its `body` already parsed as a `JokeResponse` object.

Read [the documentation of the `HttpResponse` class][angular-docs-http-response] to see what information you can extract from the response.



---
## Component interaction

.breadcrumbs[<a href="#1">Angular</a>]

As described earlier, components are Angular's fundamental building blocks.

We're going to add a few features to our application:

* The ability to **vote** on which are the best jokes.
* The ability to see the **total** number of votes and how many votes the **best** joke has had.
* The ability to **clear** all the collected votes.

.grid-50[

We could implement all of this in `AppComponent`,
but that would not be viable in a real-world scenario with more complex features.
When you have a complex page with multiple areas that each have their specific logic,
it's good practice to **isolate each part into a component**:


]
.grid-50[

<p class='center'><img src='images/master-detail-components.png' /></p>


]
---
### Adding votes to the model

.breadcrumbs[<a href="#1">Angular</a> > <a href="#63">Component interaction</a>]

Update the `Joke` model in `src/app/models/joke.ts` to have a `votes` property:

```ts
export class Joke {
  text: string;
* votes: number;
}
```

You need to update `src/app/app.component.ts` to set the initial votes to `0`:

```ts
this.jokes = [
  { text: 'Knock knock'`, votes: 0` },
  { text: 'The cake is a lie'`, votes: 0` }
];
```

You also need to update the `convertJokeResponseToJoke` function in `src/app/services/joke.service.ts`:

```ts
function convertJokeResponseToJoke(response: JokeResponse): Joke {
  return {
    text: response.value.joke,
*   votes: 0
  };
}
```

---
### Creating a child component

.breadcrumbs[<a href="#1">Angular</a> > <a href="#63">Component interaction</a>]

Let's generate our **new component**, the `JokeComponent`:

```ts
$> npm run ng generate component components/joke
```

This will create a component in the `src/app/components/joke` directory,
with its own TypeScript definition, HTML template and CSS styles (and test file).

---
#### The `JokeComponent`

.breadcrumbs[<a href="#1">Angular</a> > <a href="#63">Component interaction</a> > <a href="#65">Creating a child component</a>]

The responsibility of the new `JokeComponent` will be to display a `Joke` object,
and to provide a button to vote on the joke.

Let's add a `joke` property to the new component in `src/app/components/joke/joke.component.ts`:

```ts
// Other imports...
*import { Joke } from 'src/app/models/joke';

@Component({
  selector: 'app-joke',
  templateUrl: './joke.component.html',
  styleUrls: ['./joke.component.css']
})
export class JokeComponent implements OnInit {
* joke: Joke;
  // ...
}
```

And update the component's template in `src/app/components/joke/joke.component.html` to display the joke's text:

```html
{{ joke.text }}
```

---
### Using our new component

.breadcrumbs[<a href="#1">Angular</a> > <a href="#63">Component interaction</a>]

As you can see in our component's class, we set the `selector` of our component to `app-joke`. This means that we can add a custom tag in an HTML template to add our component to the page. Let's do so in `src/app/app.component.html`:

```html
<ul>
  <li *ngFor='let joke of jokes'>
    `<app-joke></app-joke>`
  </li>
</ul>
```

We can see on our app page that the list tries to display our two initial jokes, but failed to do so, due to not being able to read the text of both jokes:

```
ERROR TypeError: Cannot read property 'text' of undefined
```

Indeed, we told our `JokeComponent` to display the `joke.text` property in its template. Except that we didn't give it any `joke` to get the `text` from...

---
### Passing data from parent to child with input binding

.breadcrumbs[<a href="#1">Angular</a> > <a href="#63">Component interaction</a>]

We want the joke to be provided by the parent component, `AppComponent`, to the `JokeComponent` as an **input** of this component.

Annotating a component's property with the [`@Input`][angular-docs-input] decorator marks it as an **input property**.
You can do this in `src/app/components/joke/joke.component.ts`:

```ts
// Other imports...
import { Component, `Input`, OnInit } from '@angular/core';

// ...
export class JokeComponent implements OnInit {
  `@Input()` joke: Joke;
  // ...
}
```

Now, update the main component's template in `src/app/app.component.html` so that it binds each joke object to the `joke` input of the `<app-joke>` tag.
```html
<ul>
  <li *ngFor='let joke of jokes'>
    <app-joke `[joke]="joke"`></app-joke>
  </li>
</ul>
```

---
### Voting on jokes

.breadcrumbs[<a href="#1">Angular</a> > <a href="#63">Component interaction</a>]

Now that `JokeComponent` is working, we can use it to **handle the logic related to one joke**, like voting.

Add a `vote()` method to `JokeComponent` in `src/app/components/joke/joke.component.ts`:

```ts
vote() {
  this.joke.votes++;
}
```

Add these 2 lines to the component's template in `src/app/components/joke/joke.component.html`:

```html
{{ joke.text }}
*({{ joke.votes }} votes)
*<button type='button' (click)='vote()'>+1</button>
```

You can now vote!

---
### Displaying global voting information

.breadcrumbs[<a href="#1">Angular</a> > <a href="#63">Component interaction</a>]

Let's now display the **total number of votes** and the **best vote** on the page.
That's the job of the **main component**, since a `JokeComponent` only knows about its own joke,
so it can't know the total number of votes or whether its number of votes is the highest.

Add this information to `AppComponent` in `src/app/app.component.ts`:

```ts
export class AppComponent {
  // ...
* bestVote: number;
* totalVotes: number;

  constructor(private jokeService: JokeService) {
*   this.bestVote = 0;
*   this.totalVotes = 0;
    // ...
  }
  // ...
}
```

And display it in the template in `src/app/app.component.html`:

```html
<p>Total votes: {{ totalVotes }}, best vote: {{ bestVote }}</p>
```

---
### Output from child components

.breadcrumbs[<a href="#1">Angular</a> > <a href="#63">Component interaction</a>]

The vote button is in the child component's template, so `AppComponent` can't put an event listener on it directly.
Instead, we need our `JokeComponent` to have an **output** that its parent can listen to.

Annotating a component's property with the [`@Output`][angular-docs-output] decorator marks it as an **output property**.
It must be an [`EventEmitter`][angular-docs-event-emitter] (or an Observable).
Let's add one to `JokeComponent` in `src/app/components/joke/joke.component.ts` now:

```ts
import { Component, `EventEmitter`, Input, OnInit, `Output` } from '@angular/core';

// ...
export class JokeComponent implements OnInit {
  // ...
* @Output() voted: EventEmitter<Joke>;

  constructor() {
*  this.voted = new EventEmitter();
  }

  vote() {
    this.joke.votes++;
*   this.voted.emit(this.joke);
  }
}
```

---
### Listening to child component events from a parent

.breadcrumbs[<a href="#1">Angular</a> > <a href="#63">Component interaction</a>]

Let's add an `onJokeVoted()` method to `AppComponent` in `src/app/app.component.ts`:

```ts
onJokeVoted(joke: Joke) {
  this.totalVotes++;
  if (joke.votes > this.bestVote) {
    this.bestVote = joke.votes;
  }
}
```

We want this method to be called every time a vote button is clicked in a child `JokeComponent`.

From the parent's point of view, an **output property** of a child component is **just like any other DOM event**.
You bind to it using Angular's `(event)='expression'` syntax, exactly like you bind to `(click)` on a `<button>` tag.
Do that in `src/app/app.component.html`:

```html
<app-joke [joke]='joke' `(voted)='onJokeVoted(joke)'`></app-joke>
```

---
### Clearing the votes

.breadcrumbs[<a href="#1">Angular</a> > <a href="#63">Component interaction</a>]

Now that our components are already plugged together,
adding the functionality to **clear the votes** is trivial.
Add a `clearVotes()` method to the main component in `src/app/app.component.ts`.
It simply resets all votes to zero, including the jokes':

```ts
clearVotes() {
  this.bestVote = 0;
  this.totalVotes = 0;
  this.jokes.forEach(joke => joke.votes = 0);
}
```

And add a button to call it in the template in `src/app/app.component.html`:

```html
<button type='button' (click)='clearVotes()'>Clear votes</button>
```

It just works!

The `Joke` objects in the `JokeComponent` children are the same objects as the ones in the main component's `jokes` array, bound through Angular's input properties.
When you modify them in any component, Angular **automatically updates all the relevant templates**.

---
### More component interaction

.breadcrumbs[<a href="#1">Angular</a> > <a href="#63">Component interaction</a>]

These were just a few examples of how to communicate between components.

There are other ways to do it, like injecting the same **service** into multiple components.
This can be useful if two components must communicate but neither is a parent of the other, so they cannot use inputs or outputs.

Read the [documentation][angular-component-interaction] to learn more.


---
## Resources

.breadcrumbs[<a href="#1">Angular</a>]

**Documentation**

* [Angular Tour of Heroes Tutorial][angular-tour-of-heroes]
* [Angular Developer Guide][angular-guide]
  * [Automated Testing][angular-testing]
* [Angular API reference][angular-api]

**Further reading**

* [A guide to web components][a-guide-to-web-components]
* [Angular 2 components][angular-2-series-components]
* [Understanding, creating and subscribing to observables in Angular][understanding-angular-observables]
* [The Introduction to Reactive Programming You've Been Missing][intro-to-reactive-programming]

[angular]: https://angular.io
[angular-guide]: https://angular.io/guide/architecture
[angular-tour-of-heroes]: https://angular.io/tutorial
[chrome]: https://www.google.com/chrome/
[js]: ../js/
[js-modules]: ../js-modules/
[js-classes]: ../js-classes/
[ts-subject]: ../ts
[ajax]: https://developer.mozilla.org/en-US/docs/AJAX/Getting_Started
[jquery]: http://jquery.com
[html-history-api]: https://developer.mozilla.org/en-US/docs/Web/API/History_API
[web-components]: https://developer.mozilla.org/en-US/docs/Web/Web_Components
[ts]: https://www.typescriptlang.org
[chrome-dev]: https://developers.google.com/web/tools/chrome-devtools/console/
[angular-docs-ng-module]: https://angular.io/api/core/NgModule
[angular-docs-component]: https://angular.io/api/core/Component
[angular-component-styles]: https://angular.io/guide/component-styles
[dom-event]: https://developer.mozilla.org/en-US/docs/Web/API/Event
[angular-docs-ng-for]: https://angular.io/api/common/NgForOf
[angular-docs-ng-if]: https://angular.io/api/common/NgIf
[angular-docs-ng-switch]: https://angular.io/api/common/NgSwitch
[angular-structural-directives]: https://angular.io/guide/structural-directives
[advanced-angular-subject]: ../advanced-angular
[angular-docs-ng-class]: https://angular.io/api/common/NgClass
[angular-docs-ng-model]: https://angular.io/api/forms/NgModel
[angular-docs-ng-plural]: https://angular.io/api/common/NgPlural
[angular-docs-ng-style]: https://angular.io/api/common/NgStyle
[angular-docs-currency-pipe]: https://angular.io/api/common/CurrencyPipe
[angular-docs-date-pipe]: https://angular.io/api/common/DatePipe
[angular-docs-decimal-pipe]: https://angular.io/api/common/DecimalPipe
[angular-docs-lowercase-pipe]: https://angular.io/api/common/LowerCasePipe
[angular-docs-percent-pipe]: https://angular.io/api/common/PercentPipe
[angular-docs-titlecase-pipe]: https://angular.io/api/common/TitleCasePipe
[angular-docs-uppercase-pipe]: https://angular.io/api/common/UpperCasePipe
[angular-pipes]: https://angular.io/guide/pipes
[angular-docs-injectable]: https://angular.io/api/core/Injectable
[di]: https://en.wikipedia.org/wiki/Dependency_injection
[ioc]: https://en.wikipedia.org/wiki/Inversion_of_control
[js-promise]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise
[rxjs]: http://reactivex.io/rxjs/
[rxjs-subject]: ../rxjs
[intro-to-reactive-programming]: https://gist.github.com/staltz/868e7e9bc2a7b8c1f754
[angular-docs-http-client]: https://angular.io/guide/http
[js-array-map]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map
[observable-map]: http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-map
[angular-docs-http-response]: https://angular.io/api/common/http/HttpResponse
[angular-docs-input]: https://angular.io/api/core/Input
[angular-docs-event-emitter]: https://angular.io/api/core/EventEmitter
[angular-docs-output]: https://angular.io/api/core/Output
[angular-component-interaction]: https://angular.io/guide/component-interaction
[a-guide-to-web-components]: https://css-tricks.com/modular-future-web-components/
[angular-api]: https://angular.io/api
[angular-testing]: https://angular.io/guide/testing
[angular-2-series-components]: http://blog.ionic.io/angular-2-series-components/
[understanding-angular-observables]: https://hackernoon.com/understanding-creating-and-subscribing-to-observables-in-angular-426dbf0b04a3

    </textarea>
    <script src='https://embed.runkit.com'></script>
    <script src='../../subject-029dd9a58d98cf81bc86.js'></script>
  </body>
</html>
